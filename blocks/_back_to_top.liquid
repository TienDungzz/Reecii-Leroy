<div
  class="target-block relative button__back-to-top hide"
>
  <button
    class="multi-t__button p-0 flex items-center justify-center relative cursor-pointer bor-none rounded-full"
    data-target="back-to-top"
    role="button"
    aria-haspopup="dialog"
    aria-label="{{ 'content.back_to_top' | t }}"
    {{ block.shopify_attributes }}
  >
    <span class="svg-wrapper">
      {{- 'icon-arrow.svg' | inline_asset_content -}}

      {% comment %} <svg class="progress-circle absolute inset-0" width="100%" height="100%" viewBox="-1 -1 102 102">
        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
      </svg>
      <svg
        class="progress-circle progress-circle-fill absolute inset-0"
        width="100%"
        height="100%"
        viewBox="-1 -1 102 102"
      >
        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
      </svg> {% endcomment %}

      <svg class="progress-circle progress-circle-fill svg-content absolute inset-0" width="100%" height="100%" viewBox="-1 -1 102 102">
        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98" style="transition: stroke-dashoffset 10ms linear; stroke-dasharray: 307.919, 307.919; stroke-dashoffset: 307.919;"></path>
      </svg>
    </span>
  </button>
  <span class="target-block--tooltip">{{ 'content.back_to_top' | t }}</span>
</div>

<script defer="defer">
  document.addEventListener('DOMContentLoaded', () => {
    var progressPath = document.querySelector('.button__back-to-top .progress-circle path');
    if (!progressPath) return;
    var pathLength = progressPath.getTotalLength();

    // Set initial style for path
    progressPath.style.transition = progressPath.style.WebkitTransition = 'none';
    progressPath.style.strokeDasharray = pathLength + ' ' + pathLength;
    progressPath.style.strokeDashoffset = pathLength;
    progressPath.getBoundingClientRect();
    // Mặc định không cần animation vì chúng ta tự animate theo rAF
    progressPath.style.transition = progressPath.style.WebkitTransition = 'none';

    var lastProgress = null;

    function getScrollY() {
      if (window.LenisInstance && typeof window.LenisInstance.scroll === 'number') {
        return window.LenisInstance.scroll;
      } else if (window.LenisInstance && window.LenisInstance.targetScroll != null) {
        return window.LenisInstance.targetScroll;
      }
      return window.scrollY || window.pageYOffset;
    }

    function updateProgress() {
      var scroll = getScrollY();
      var height = document.documentElement.scrollHeight - window.innerHeight;
      if (height <= 0) height = 1;
      var progress = pathLength - (scroll * pathLength) / height;
      // Only update strokeDashoffset if changed (avoid repaints)
      if (lastProgress !== progress) {
        progressPath.style.strokeDashoffset = progress;
        lastProgress = progress;
      }
    }

    // Use rAF loop for best performance
    function rafLoop() {
      updateProgress();
      window.requestAnimationFrame(rafLoop);
    }

    // On resize/document height change, force update
    window.addEventListener('resize', updateProgress);
    // Also recalc immediately, in case load in scrolled state
    updateProgress();
    // Start the rAF loop
    rafLoop();
  });

</script>

{% schema %}
{
  "name": "t:names.back_to_top",
  "tag": null,
  "presets": [
    {
      "name": "t:names.back_to_top"
    }
  ]
}
{% endschema %}
